C51 COMPILER V8.12   SCALERCOMMONFLASHWRITE                                                05/25/2022 15:40:54 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE SCALERCOMMONFLASHWRITE
OBJECT MODULE PLACED IN .\Output\ScalerCommonFlashWrite.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\ScalerCommonFunction\Lib\Code\ScalerCommonNVRam\ScalerCommonFlashWrit
                    -e.c LARGE OPTIMIZE(9,SPEED) INCDIR(..\..\..\Common;..\Header;.\Header;..\..\ScalerFunction\Lib\Header;..\..\ScalerFuncti
                    -on\Header;..\..\ScalerCommonFunction\Lib\Header;..\..\ScalerCommonFunction\Header;..\..\RL6432_Series_Common\Lib\Header;
                    -..\..\RL6432_Series_Common\Header) DEFINE(_TRANSLATOR_SUPPORT=_OFF,_SCALER_TYPE=_RL6432_SERIES) DEBUG OBJECTEXTEND PRINT
                    -(.\Output\ScalerCommonFlashWrite.lst) OBJECT(.\Output\ScalerCommonFlashWrite.obj)

line level    source

   1          /********************************************************************************/
   2          /*   The  Software  is  proprietary,  confidential,  and  valuable to Realtek   */
   3          /*   Semiconductor  Corporation  ("Realtek").  All  rights, including but not   */
   4          /*   limited  to  copyrights,  patents,  trademarks, trade secrets, mask work   */
   5          /*   rights, and other similar rights and interests, are reserved to Realtek.   */
   6          /*   Without  prior  written  consent  from  Realtek,  copying, reproduction,   */
   7          /*   modification,  distribution,  or  otherwise  is strictly prohibited. The   */
   8          /*   Software  shall  be  kept  strictly  in  confidence,  and  shall  not be   */
   9          /*   disclosed to or otherwise accessed by any third party.                     */
  10          /*   c<2003> - <2012>                                                           */
  11          /*   The Software is provided "AS IS" without any warranty of any kind,         */
  12          /*   express, implied, statutory or otherwise.                                  */
  13          /********************************************************************************/
  14          
  15          //----------------------------------------------------------------------------------------------------
  16          // ID Code      : ScalerCommonFlashWrite.c No.0000
  17          // Update Note  :
  18          //----------------------------------------------------------------------------------------------------
  19          
  20          #define __SCLAER_COMMON_FLASH_WRITE__
  21          
  22          #include "ScalerCommonNVRamLibInternalInclude.h"
  23          
  24          //****************************************************************************
  25          // DEFINITIONS / MACROS
  26          //****************************************************************************
  27          
  28          //****************************************************************************
  29          // STRUCT / TYPE / ENUM DEFINITTIONS
  30          //****************************************************************************
  31          
  32          //****************************************************************************
  33          // CODE TABLES
  34          //****************************************************************************
  35          
  36          //****************************************************************************
  37          // VARIABLE DECLARATIONS
  38          //****************************************************************************
  39          
  40          //****************************************************************************
  41          // FUNCTION DECLARATIONS
  42          //****************************************************************************
  43          bit ScalerFlashWrite(BYTE ucBank, WORD usAddr, WORD usLength, BYTE *pucData);
  44          
  45          //****************************************************************************
  46          // FUNCTION DEFINITIONS
  47          //****************************************************************************
  48          //--------------------------------------------------
  49          // Description  : Save data to flash
  50          // Input Value  : ucBank: bank index
  51          //                usAddr: address in ucBank
C51 COMPILER V8.12   SCALERCOMMONFLASHWRITE                                                05/25/2022 15:40:54 PAGE 2   

  52          //                ucLength: the data length to save
  53          //                pucData: data buffer to save
  54          // Output Value : _TRUE for save success and _FALSE for save fail
  55          //--------------------------------------------------
  56          bit ScalerFlashWrite(BYTE ucBank, WORD usAddr, WORD usLength, BYTE *pucData)
  57          {
  58   1          BYTE ucPage = 0;
  59   1          WORD usIndex = 0;
  60   1      
  61   1          BYTE ucStartPage = 0;
  62   1          BYTE ucEndPage = 0;
  63   1          WORD usCurrentAddr = 0;
  64   1          WORD usLeftLength = 0;
  65   1          WORD usCurrentLength = 0;
  66   1      
  67   1      #if(_HW_FLASH_ACCESS_METHOD == _XDATA_MAP_ACCESS)
  68   1          BYTE ucBankBackup = 0;
  69   1          BYTE ucBackup_E000 = ScalerGetByte(0xE000);
  70   1          BYTE ucDdcStatus = 0;
  71   1          BYTE ucXdataMapping = _TRUE;
  72   1      #endif
  73   1      
  74   1          // The access bank is smaller than than the start bank or across bank
  75   1          if((ucBank < MCU_FFFD_XDATA_BANK_START) || (((DWORD)usAddr + usLength) > 0x10000))
  76   1          {
  77   2              return _FALSE;
  78   2          }
  79   1      
  80   1          // Need detect flash type when never detected
  81   1          if(g_ucFlashType == _FLASH_UNDETECT)
  82   1          {
  83   2              ScalerFlashDetectFlashType();
  84   2          }
  85   1      
  86   1          ///////////////////////////////////
  87   1          //Avoid Write Across Page(Sector)//
  88   1          ///////////////////////////////////
  89   1      
  90   1          ucStartPage = usAddr / _FLASH_PAGE_SIZE;
  91   1          ucEndPage = ((DWORD)usAddr + usLength) / _FLASH_PAGE_SIZE;
  92   1          usCurrentAddr = usAddr;
  93   1          usLeftLength = usLength;
  94   1      
  95   1      #if(_HW_FLASH_ACCESS_METHOD == _FLASH_PORT_ACCESS)
              
                  // Enable flash access and address auto increase
                  MCU_FF7C_ACCESS_FLASH_DATA_CTRL |= (_BIT1 | _BIT0);
              
              #elif(_HW_FLASH_ACCESS_METHOD == _XDATA_MAP_ACCESS)
 101   1      
 102   1          // Check xdata mapping address,
 103   1          if(((DWORD)usAddr + usLength) < _XRAM_ADDR_START)
 104   1          {
 105   2              // Enable XData Write to Flash Function
 106   2              MCU_FFF0_XDATA_SPI_FLASH_WRITE_PROTECT &= ~_BIT0;
 107   2      
 108   2              // Disable Access Flash by 0xFF7B
 109   2              MCU_FF7C_ACCESS_FLASH_DATA_CTRL &= ~_BIT0;
 110   2      
 111   2              // Backup the current xdata bank index
 112   2              ucBankBackup = MCU_FFFE_XDATA_BANK_SEL;
 113   2      
C51 COMPILER V8.12   SCALERCOMMONFLASHWRITE                                                05/25/2022 15:40:54 PAGE 3   

 114   2              // Change to the target xdata bank = Bank Start + Bank Select Offset
 115   2              MCU_FFFE_XDATA_BANK_SEL = ucBank - MCU_FFFD_XDATA_BANK_START;
 116   2          }
 117   1          else
 118   1          {
 119   2              ucXdataMapping = _FALSE;
 120   2      
 121   2              // Disable Access Flash by 0xFF7B
 122   2              MCU_FF7C_ACCESS_FLASH_DATA_CTRL &= ~_BIT0;
 123   2      
 124   2              if(ScalerSyncVGAUseEmbeddedEDID() == _TRUE)
 125   2              {
 126   3                  // Backup DDC status
 127   3                  ucDdcStatus = ScalerSyncGetDdcForceNackStatus(_A0_INPUT_PORT);
 128   3      
 129   3                  if(ucDdcStatus == _FALSE)
 130   3                  {
 131   4                      // Check for Ddc Busy
 132   4                      ScalerSyncVGADdcCheckBusyAndForceNack();
 133   4                  }
 134   3      
 135   3                  // Backup VGA EDID data in address = 0xE000
 136   3                  ucBackup_E000 = ScalerGetByte(0xE000);
 137   3              }
 138   2          }
 139   1      #endif
 140   1      
 141   1          for(ucPage = ucStartPage; ucPage <= ucEndPage; ucPage++)
 142   1          {
 143   2      #if(_HW_FLASH_ACCESS_METHOD == _FLASH_PORT_ACCESS)
                      MCU_FF78_ACCESS_FLASH_ADDR_0 = ucBank;
                      MCU_FF79_ACCESS_FLASH_ADDR_1 = (BYTE)(usCurrentAddr >> 8);
                      MCU_FF7A_ACCESS_FLASH_ADDR_2 = (BYTE)(usCurrentAddr);
              #endif
 148   2      
 149   2              // Assign usCurrentLength
 150   2              if(((DWORD)_FLASH_PAGE_SIZE * (ucPage + 1)) <= (usCurrentAddr + usLeftLength))
 151   2              {
 152   3                  usCurrentLength = ((DWORD)_FLASH_PAGE_SIZE * (ucPage + 1)) - usCurrentAddr;
 153   3              }
 154   2              else
 155   2              {
 156   3                  usCurrentLength = usLeftLength;
 157   3              }
 158   2      
 159   2              // Write usCurrentLength Bytes Data From usCurrentAddr
 160   2              if((g_ucFlashType == _FLASH_MX25L2026) || (g_ucFlashType == _FLASH_MX25L4026D) || (g_ucFlashType =
             -= _FLASH_BY25D40C))
 161   2              {
 162   3                  for(usIndex = usCurrentAddr - usAddr; usIndex < (usCurrentAddr - usAddr) + usCurrentLength; us
             -Index++)
 163   3                  {
 164   4                      ScalerFlashWREN(ucBank, ucPage);
 165   4      
 166   4                      // When Flash Write SR Use EWSR Mode,Page Program Need Use 0x06 OP Code
 167   4                      if((MCU_FF60_COMMON_INST_EN & 0xE0) == _BIT7)
 168   4                      {
 169   5                          MCU_FF63_EWSR_OP_CODE = 0x06;
 170   5                      }
 171   4      
 172   4      #if(_HW_FLASH_ACCESS_METHOD == _FLASH_PORT_ACCESS)
              
C51 COMPILER V8.12   SCALERCOMMONFLASHWRITE                                                05/25/2022 15:40:54 PAGE 4   

                              MCU_FF7B_ACCESS_FLASH_DATA_PORT = pucData[usIndex];
              
              #elif(_HW_FLASH_ACCESS_METHOD == _XDATA_MAP_ACCESS)
 177   4      
 178   4                      // Disable All interrupt
 179   4                      EA = _DISABLE;
 180   4      
 181   4                      if(ucXdataMapping == _FALSE)
 182   4                      {
 183   5                          MCU_FF64_FLASH_PROG_ISP0 = ucBank;
 184   5                          MCU_FF65_FLASH_PROG_ISP1 = (BYTE)((usAddr + usIndex) >> 8);
 185   5                          MCU_FF66_FLASH_PROG_ISP2 = (BYTE)(usAddr + usIndex);
 186   5      
 187   5                          // Set Data length 1 byte
 188   5                          MCU_FF71_PROGRAM_LENGTH = 0x00;
 189   5      
 190   5                          ScalerSetByte(0xE000, pucData[usIndex]);
 191   5      
 192   5                          // ISP programming on-going
 193   5                          MCU_SET_BIT_WITH_CKCON(MCU_FF6F_PROGRAM_INSTRUCTION, ~_BIT5, _BIT5, _CKCON_MOVX_9_CYCL
             -E);
 194   5                      }
 195   4                      else
 196   4                      {
 197   5                          // Disable Scaler Address Remapping xData Space
 198   5                          MCU_FFFC_BANK_SWICH_CONTROL &= ~_BIT4;
 199   5      
 200   5                          // Use Xdata Mapping to Flash, Xdata Mapping Limit Range as 0x0000~0xD6FF, 0xFD00~0xFD
             -FF, 0xFE00~0xFEFF
 201   5                          ScalerSetByte(usAddr + usIndex, pucData[usIndex]);
 202   5      
 203   5                          // Enable Scaler Address Remapping xData Space
 204   5                          MCU_FFFC_BANK_SWICH_CONTROL |= _BIT4;
 205   5                      }
 206   4      
 207   4                      // Enable All interrupt
 208   4                      EA = _ENABLE;
 209   4      #endif
 210   4                  }
 211   3      
 212   3                  // After Page Program, Back Up EWSR OP Code 0x50
 213   3                  if((MCU_FF60_COMMON_INST_EN & 0xE0) == _BIT7)
 214   3                  {
 215   4                      MCU_FF63_EWSR_OP_CODE = 0x50;
 216   4                  }
 217   3      
 218   3                  ScalerFlashWRDis();
 219   3              }
 220   2              else
 221   2              {
 222   3                  ScalerFlashWREN(ucBank, ucPage);
 223   3      
 224   3                  // When Flash Write SR Use EWSR Mode, Page Program Need Use 0x06 OP Code
 225   3                  if((MCU_FF60_COMMON_INST_EN & 0xE0) == _BIT7)
 226   3                  {
 227   4                      MCU_FF63_EWSR_OP_CODE = 0x06;
 228   4                  }
 229   3      
 230   3                  for(usIndex = usCurrentAddr - usAddr; usIndex < (usCurrentAddr - usAddr) + usCurrentLength; us
             -Index++)
 231   3                  {
 232   4      #if(_HW_FLASH_ACCESS_METHOD == _FLASH_PORT_ACCESS)
C51 COMPILER V8.12   SCALERCOMMONFLASHWRITE                                                05/25/2022 15:40:54 PAGE 5   

              
                              MCU_FF7B_ACCESS_FLASH_DATA_PORT = pucData[usIndex];
              
              #elif(_HW_FLASH_ACCESS_METHOD == _XDATA_MAP_ACCESS)
 237   4      
 238   4                      // Disable All interrupt
 239   4                      EA = _DISABLE;
 240   4      
 241   4                      if(ucXdataMapping == _FALSE)
 242   4                      {
 243   5                          MCU_FF64_FLASH_PROG_ISP0 = ucBank;
 244   5                          MCU_FF65_FLASH_PROG_ISP1 = (BYTE)((usAddr + usIndex) >> 8);
 245   5                          MCU_FF66_FLASH_PROG_ISP2 = (BYTE)(usAddr + usIndex);
 246   5      
 247   5                          // Set Data length 1 byte
 248   5                          MCU_FF71_PROGRAM_LENGTH = 0x00;
 249   5      
 250   5                          ScalerSetByte(0xE000, pucData[usIndex]);
 251   5      
 252   5                          // ISP programming on-going
 253   5                          MCU_SET_BIT_WITH_CKCON(MCU_FF6F_PROGRAM_INSTRUCTION, ~_BIT5, _BIT5, _CKCON_MOVX_9_CYCL
             -E);
 254   5                      }
 255   4                      else
 256   4                      {
 257   5                          // Disable Scaler Address Remapping xData Space
 258   5                          MCU_FFFC_BANK_SWICH_CONTROL &= ~_BIT4;
 259   5      
 260   5                          // Use Xdata Mapping to Flash, Xdata Mapping Limit Range as 0x0000~0xD6FF, 0xFD00~0xFD
             -FF, 0xFE00~0xFEFF
 261   5                          ScalerSetByte(usAddr + usIndex, pucData[usIndex]);
 262   5      
 263   5                          // Enable Scaler Address Remapping xData Space
 264   5                          MCU_FFFC_BANK_SWICH_CONTROL |= _BIT4;
 265   5                      }
 266   4      
 267   4                      // Enable All interrupt
 268   4                      EA = _ENABLE;
 269   4      #endif
 270   4                  }
 271   3      
 272   3                  // After Page Program, Back Up EWSR OP Code 0x50
 273   3                  if((MCU_FF60_COMMON_INST_EN & 0xE0) == _BIT7)
 274   3                  {
 275   4                      MCU_FF63_EWSR_OP_CODE = 0x50;
 276   4                  }
 277   3      
 278   3                  ScalerFlashWRDis();
 279   3              }
 280   2      
 281   2              // Assign New usCurrentLength and usLeftLength
 282   2              usCurrentAddr = usCurrentAddr + usCurrentLength;
 283   2              usLeftLength = usLeftLength - usCurrentLength;
 284   2          }
 285   1      
 286   1      #if(_HW_FLASH_ACCESS_METHOD == _FLASH_PORT_ACCESS)
              
                  // Disable flash access
                  MCU_FF7C_ACCESS_FLASH_DATA_CTRL &= ~_BIT0;
              
              #elif(_HW_FLASH_ACCESS_METHOD == _XDATA_MAP_ACCESS)
 292   1      
C51 COMPILER V8.12   SCALERCOMMONFLASHWRITE                                                05/25/2022 15:40:54 PAGE 6   

 293   1          if(ucXdataMapping == _TRUE)
 294   1          {
 295   2              // Restore the xdata bank
 296   2              MCU_FFFE_XDATA_BANK_SEL = ucBankBackup;
 297   2          }
 298   1          else
 299   1          {
 300   2              if(ScalerSyncVGAUseEmbeddedEDID() == _TRUE)
 301   2              {
 302   3                  // Restore data 0f address 0xE000
 303   3                  ScalerSetByte(0xE000, ucBackup_E000);
 304   3      
 305   3                  if(ucDdcStatus == _FALSE)
 306   3                  {
 307   4                      // Restore Force nack Ddc Channel
 308   4                      ScalerSyncSetDdcForceNack(_A0_INPUT_PORT, ucDdcStatus);
 309   4                  }
 310   3              }
 311   2          }
 312   1      #endif
 313   1      
 314   1          return _TRUE;
 315   1      }
 316          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    902    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
